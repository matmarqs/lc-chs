#include <stdbool.h>

/***********************/

/* this solution could be improved by a HashMap in the function isSubstring */

#include <stdlib.h>
#include <string.h>

bool isSubstring(char *s, int len_s, char *sub, int len_sub) {
    for (int i = 0; i < len_s - len_sub + 1; i++) {
        bool substring = true;
        for (int j = 0; j < len_sub; j++) {
            if (sub[j] != s[i+j]) {
                substring = false;
            }
        }
        if (substring)
            return true;
    }
    return false;
}

/* generated by DeepSeek. This beats 100% and is O(N) */
bool isSubstringPresent(char* s) {
    int len_s = strlen(s);
    if (len_s < 2) return false;
    
    // Precompute all possible 2-character substrings from the reversed string
    // and store them in a hash table (implemented as a simple array for ASCII)
    bool rev_substrings[256*256] = {false};
    
    // Build reversed string
    char *rev = (char *) malloc(sizeof(char) * (len_s+1));
    for (int i = 0; i < len_s; i++) {
        rev[i] = s[len_s-1-i];
    }
    rev[len_s] = '\0';
    
    // Populate hash table with all 2-char substrings from reversed string
    for (int i = 0; i < len_s - 1; i++) {
        unsigned short key = (rev[i] << 8) | rev[i+1];
        rev_substrings[key] = true;
    }
    /* actually, this is a HashSet */
    /* it has cardinality 256*256 for all possible strings of length 2 */
    /* it has perfect hashing, with the hash function h(s) = (s[0] << 8) | s[1]; */
    /* which is just the ASCII bytes of the first char and second char concatenated */
    
    // Check all 2-char substrings in original string against the hash table
    bool result = false;
    for (int i = 0; i < len_s - 1; i++) {
        unsigned short key = (s[i] << 8) | s[i+1];
        if (rev_substrings[key]) {
            result = true;
            break;
        }
    }
    
    free(rev);
    return result;
}

bool isSubstringPresent_Mine(char* s) {
    int len_s = strlen(s);
    char *rev = (char *) malloc(sizeof(char) * (len_s+1));
    for (int i = len_s-1; i >= 0; i--) {
        rev[i] = s[len_s-1-i];
    }
    rev[len_s] = '\0';

    int result = false;
    for (int i = 0; i < len_s - 1; i++) {
        if (isSubstring(rev, len_s, s+i, 2)) {
            result = true;
            break;
        }
    }

    free(rev);
    return result;
}

